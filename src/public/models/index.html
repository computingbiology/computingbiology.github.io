<!doctype html>
<html class="no-js" lang="en-us">
  <head>
    <meta charset="utf-8">
    <title>Models of Computation | Computational Biology / Biological Computing</title>
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="https://computingbiology.github.io/css/foundation.min.css">
    <link rel="stylesheet" href="https://computingbiology.github.io/css/highlight.min.css">
    <link rel="stylesheet" href="https://computingbiology.github.io/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://computingbiology.github.io/css/academicons.min.css">
    <link rel="stylesheet" href="https://computingbiology.github.io/css/fonts.css">
    <link rel="stylesheet" href="https://computingbiology.github.io/css/finite.css">
    <link rel="shortcut icon" href="/images/dna.png">

    <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

    
  </head>
  <body>
      
    <header>
      <nav class="nav-bar">
	
	  <div class="title-bar" data-responsive-toggle="site-menu" data-hide-for="medium">	      
	    <button class="site-hamburger" type="button" data-toggle>
	      <i class="fa fa-bars fa-lg" aria-hidden="true"></i>
	    </button>
	    <div class="title-bar-title site-title">
	      <a href="https://computingbiology.github.io/">Computational Biology / Biological Computing</a>
	    </div>
	    <div class="title-bar-right pull-right">
	      


	    </div>
	  </div>
	    
	  
	    <div class="top-bar" id="site-menu" >	      
	      <div class="top-bar-title show-for-medium site-title">
		<a href="https://computingbiology.github.io/">Computational Biology / Biological Computing</a>
	      </div>
	      <div class="top-bar-left">
		<ul class="menu vertical medium-horizontal">
		  
		  
		</ul>
	      </div>
	      <div class="top-bar-right show-for-medium">
		


	      </div>
	    </div>
	  
	</nav>
      
    </header>
    
    <main>
      

<div class="content">
    <article class="article" itemscope itemtype="http://schema.org/Article">
      <h1 itemprop="name" class="pagetitle">Models of Computation</h1>
      <div class="post-body" itemprop="articleBody">
        <p>To reason precisely about what computers can and cannot do, we need
abstract models that capture the things we think are important but
avoid the complexities of physical objects.</p>
<div class="shortsection">Models and Mathematics</div>
<p>The physical world is messy and suffers from arbitrary limits —
this applies both to the physical computing devices we use (which
always have some probability of failing and can&rsquo;t even do arithmetic
correcly) and even more so to biological systems we consider in this
class. Mathematics is precise and unconstrained — we can
define formal systems that always behave in the prescribed way, can
do operations without generating heat, and can be
infinite. Mathematical models are useful because we can reason about
them using the formal tools of mathematics, and can abstract away
physical complexities and finite limits of physical
reality. Mathematical models have proven uncannily useful in
understanding and predicting properties of the physical world, but
when we use them we have to be mindful that they are abstractions
that avoid many of the messy aspects of physical reality.</p>
<div class="additionalreading">
<center><b>Additional Materials</b></center>
<ul>
<li>Eugene Wigner. <a href="/docs/wigner1960.pdf"><em>The Unreasonable Effectivenss of Mathematics in the Natural Sciences</em></a>.  Communications in Pure and Applied Mathematics, 1960.</li>
<li>Richard Hamming. <a href="/docs/hamming1980.pdf"><em>The Unreasonable Effectiveness of Mathematics</em></a>. The American Mathematical Monthly, 87(2), 81–90.</li>
<li>For an important counter-argument, see Alon Halevy, Peter Norvig,
Fernando Pereira, <a href="/docs/halevy2009.pdf"><em>The Unreasonable Effectiveness of
Data</em></a>, IEEE Intelligent Systems, 2009. See
also Peter Norvig&rsquo;s talk <a href="https://www.youtube.com/watch?v=yvDCzhbjYWs"><em>The Unreasonable Effectiveness of
Data</em></a>, October
2011. <a href="https://www.youtube.com/watch?v=PI8Fo1vzUPM">Norvig</a> starts
with the observation that Wigner&rsquo;s claims about the effectiveness of
simple mathematics to explain the universe are valid for a
physicist, but not for biology - very little in biology can be
explained with a short, simple equation. (The rest of the talk is
about effectiveness of ML to solve problems in vision and language,
but doesn&rsquo;t return to biology.)
</div>
</li>
</ul>
<div class="shortsection">Modeling Computers</div>
<p>To model a <em>computer</em>, we need to: (1) define
a set of mathematical objects that correspond to instances of the
computer we are modeling; and (2) define an execution model that shows
how any element in that set in that model executes. Note that when we
say <em>computer</em> in theoretical computer science, we mean a complete
computing system — there is no separation between &ldquo;hardware&rdquo; and
&ldquo;software&rdquo; as there is in informal use of &ldquo;computer&rdquo; as a physical
device that doens&rsquo;t do anything without its program. In our
theoretical computing models, the input may include a description of a
program (and often does), but the mathematical object that we are
modeling includes everything needed to perform a computation.</p>
<p>An <em>execution</em> of a computer takes (1) an <em>input</em>, (2) does <em>some
processing</em>, and (3) produces an <em>output</em>.  So, the execution model
for a model computer needs to explain how the input is represented
(typically by a finite string of bits), and how processing is done
(this typically requires defining some kind of abstract machine that
operates on the input, and uses some kind of <em>storage</em> (also called
<em>memory</em>) to keep track of what it is doing), and a way to know when
an execution is finished and to interpret the final state of the
abstract machine (including its memory) as the <em>output</em>.</p>
<div class="additionalreading">
<center><b>Additional Materials</b></center>
<ul>
<li>
<p><a href="https://introtcs.org/public/lec_03_computation.html">Defining Computation</a>, Chapter 3 of Boaz Barak&rsquo;s <a href="https://introtcs.org/"><em>Introduction to Theoretical Computer Science</em></a> book (this is the book I have used when I teach or co-teach <a href="https://uvatoc.github.io/">cs3102: Theory of Computation</a>, so most additional materials lists will include other chapters from the book, which we refer to as the <em>TCS book</em>).</p>
</li>
<li>
<p>Video lectures (by Nathan Brunelle) from <a href="https://uvatoc.github.io/f20/week2/">cs3102 course</a>: <a href="https://www.youtube.com/watch?v=L3ueFMGM6pk"><em>What is a Computer?</em></a> (7:30); <a href="https://www.youtube.com/watch?v=Zg4FUYbwLqY&amp;feature=emb_imp_woyt"><em>Modeling Computers</em></a> (8:16).</p>
</li>
</ul>
</div>
<div class="shortsection"><a name="terminology"></a>Terminology</div>
We discuss two examples of computing models soon, but first introduce some important terminology. When discussing computing, several terms that are often used
informally are used in a very precise way and the precise definitions
of these terms are important for understanding what statements using
them mean both in theory, and what such statements imply in
practice. Some important terms to understand precisely:
<ul>
<li><strong>Functions</strong>: a <em>function</em> is a relation that maps an input to an
output. The set of possible inputs to a function is known as the
<em>domain</em>; the set of possible outputs is its <em>codomain</em>. If the
function is defined for all elements of the domain it is <em>total</em>;
if not, it is <em>partial</em>. A function is defined by how it maps
inputs to outputs, and there are many different ways to describe a
function. A finite function (where the input size if fixed) can be
defined by a table that gives the output for each possible input
(as the input size becomes larger than a few bits, though, this
becomes infeasible in practice, but it is still useful to think of
functions this way). We can define more complex functions by
giving the property the output should have. Note that the term
function is often (mis)used by programmers and programming
languages to mean a procedure for doing computation that takes
some input parameters and returns an output. This is very
different from a mathematical function, and the two should not be
confused.</li>
<li><strong>Algorithms</strong>: an <em>algorithm</em> is a precise description of steps to
perform. An algorithm <em>computes</em> a function if it is guaranteed to
always produce a correct output for any input (that is, it
implement the input-output mapping of the function). This means it
must always finish and output a result, and the output it produces
must be the correct output for the given input. We talk about
<em>solving</em> a problem by providing an <em>algorithm</em> that computes a
function that satisfies the requirements of the problem.</li>
</ul>
<div class="additionalreading">
<center><b>Additional Materials</b></center>
<ul>
<li>A good discrete mathematics course should make you comfortable thinking about functions, and the terms used above. If you are not confident on this material, read Chapter 4 of Lehman, Leighton, and Meyer&rsquo;s <a href="https://uvacs2102.github.io/docs/mcs.pdf"><em>Mathematics for Computer Science</em></a> (this is the book often used for <a href="https://uvacs2102.github.io/">cs2102: Discrete Mathematics</a>).</li>
</ul>
</div>
<div class="shortsection">Boolean Circuits and Turing Machines</div>
<p>Two useful and widely used theoretical models of computers are
<em>Boolean circuits</em> and <em>Turing machines</em> (in this class, we will
assume clear understanding of these models, and some variations on
them, and may also use a replacement grammar model of computation
(Lambda Calculus), but will introduce it in class).  We provide a
refresher summary of these two models below, but won&rsquo;t provide a
detailed introduction to these models here. So, if you are not already
familiar with them follow the links in the Additional Materials below.</p>
<table>
<tr><th width="15%">Model</th><th width="37%">Boolean Circuit</th><th width="48%">Turing Machine</th></tr>
<tr><td align="center">Input</td><td><b>Fixed-length</b> sequence of bits, each input bit is one input wire for the circuit</td><td><b>Finite</b> sequence of bits of <b>any length</b>, written from left to write on a infinite tape. When the machine starts execution the rest of the tape is blank, and the tape head is at the leftmost (first) input bit.</td></tr>
<tr><td align="center">Processing</td><td>Boolean logical operations (e.g., <span class="op">AND</span>, <span class="op">OR</span>, <span class="op">NOT</span>) connected in an acyclic graph. Each Boolean operation (sometimes called a <em>gate</em>) takes a few input bits (e.g., 2 for <span class="op">AND</span> and <span class="op">OR</span>, 1 for <span class="op">NOT</span>) and outputs one output bit)
</td><td>State machine with a tape head, each step it can read the current square on the tape, write a new symbol in that square, move (<span class="op">left</span>, <span class="op">right</span>, or <span class="op">halt</span>), and transition to an internal state</td></tr>
<tr><td align="center">Termination</td><td>Always terminates since circuit is acyclic</td><td>Terminates if a <span class="op">halt</span> transition is executed (but may run forever without producing any output)</td></tr>
<tr><td align="center">Output</td><td>Values on the output wires of the circuit</td><td>Sequence of symbols on the tape when the machine terminates</td></tr>
<tr><td align="center">Functions</td><td>All finite functions</td><td>
The <em>computable functions</em> (by definition &mdash; the computable functions are defined as the set of functions that can be computed by a Turing Machine)</td></tr>
</table>
<div class="additionalreading">
<center><b>Additional Materials</b></center>
<ul>
<li>
<p>For an introduction to the Boolean circuit model of computation see <a href="https://introtcs.org/public/lec_03_computation.html#booleancircuitsec">Chapter 3.3</a> of the TCS book, and these video lectures from <a href="https://uvatoc.github.io/f20/week2/">cs3102</a>: <a href="https://www.youtube.com/watch?v=spadNZCSkmk">AND-OR-NOT</a> (4:32), <a href="https://www.youtube.com/watch?v=GpVEm7bAqH0&amp;t=4s"><em>Programming with AND, OR, NOT</em></a> (9:35), <a href="https://www.youtube.com/watch?v=lim78IpB8AI"><em>Boolean Circuits</em></a> (10:31).</p>
</li>
<li>
<p>For an introduction to the Turing Machine model of computation see <a href="https://introtcs.org/public/lec_06_loops.html">Chapter 6: Loops and Infinity</a> (TCS Book) and these video lectures from <a href="https://uvatoc.github.io/f20/week8/">cs3102</a>: <a href="https://www.youtube.com/watch?v=Xx_GeourSOQ&amp;feature=emb_imp_woyt"><em>Turing Machines</em></a> (5:37), <a href="https://www.youtube.com/watch?v=wN5DPmz0hgg&amp;feature=emb_imp_woyt"><em>Turing Machine Examples</em></a> (11:40), <a href="https://www.youtube.com/watch?v=E-OK7hSyMNE&amp;feature=emb_imp_woyt"><em>What was Turing&rsquo;s Model Modeling</em></a> (includes review of other computing models) (15:56), <a href="https://www.youtube.com/watch?v=fulQIGM0jUQ&amp;feature=emb_imp_woyt"><em>Turing Machine Execution</em></a> (9:13).</p>
</div>
</li>
</ul>
<div class="shortsection">Universality</div>
<p>One of the most important insights that comes from formally modeling
computing is that the sets of functions that can be computed by
particular computing models are very robust to slight (and sometimes
even major) changes to the model, and many seemingly very different
models of computing can compute exactly the same sets of
functions. This ability to make one machine do anything is why
programming is so powerful: using one simple (at least abstractly)
computing engine, we can perform any computation by finding the
right program.</p>
<p>For <em>finite functions</em> (where the input to the function is a
fixed-length binary string), there is a Boolean circuit that computes
every finite function using only two-bit <span class="op">AND</span>,
two-bit <span class="op">OR</span>, and one-bit <span
class="op">NOT</span> operations. We can compute exactly the same set
of functions (that is, all finite functions) using Boolean circuits
composed of just two-bit <span class="op">NAND</span>. This can be
proven by showing how to compute the each of the <span
class="op">AND</span>, <span class="op">OR</span>, and <span
class="op">NOT</span> operations using a Boolean circuit made of only
<span class="op">NAND</span> gates. We call sets of gates that can be
used as the components of Boolean circuits that are capable of
computing every finite function a <em>universal gate set</em>.</p>
<p>For functions where the input length is unbounded (but still finite),
a Turing Machine is <em>universal</em>, in the sense that it can compute
every function that can be computed by every other ``reasonable&rsquo;&rsquo;
computing model. (What it means for a computing model to be reasonable
is either circularly defined as those that are equivalent in power to
a Turing Machine, or defined intuitively as anything that could be
done by a human computer following precise rules with unlimited
scratch paper, which was what Turing was originally modeling, but also
covers many variations on Turing Machines as well as more different
computing models like replacement grammars and random-access memory
machines.) We can prove a computing model is <em>universal</em>, but showing
that it can simulate a Turing Machine; we can prove that it is no more
powerful than a Turing Machine by showing how a Turing Machine can
simulate the new model.</p>
<div class="additionalreading">
<center><b>Additional Materials</b></center>
<ul>
<li>TCS <a href="https://introtcs.org/public/lec_03_computation.html#equivalence-of-all-these-models">Chapter 3.7: Equivalence of all these models</a> proves that several models are equivalent to the Boolean <span class="op">AND</span>,
<span class="op">OR</span>, <span class="op">NOT</span> circuits.</li>
<li>This video lecture shows the equivalence of <span class="op">NAND</span> circuits: <a href="https://www.youtube.com/watch?v=VlcURykDg_A&amp;feature=emb_imp_woyt"><em>Equivalence of NAND and AON Computing Models</em></a> (9:35).</li>
<li>TCS <a href="https://introtcs.org/public/lec_08_uncomputability.html">Chapter 9: <em>Universality and uncomputability</em></a> explains universal machines and how they were used to show that some problems are uncomputable.</li>
<li>This video lecture is on <a href="https://www.youtube.com/watch?v=Ij01xiZDN8k&amp;feature=emb_imp_woyt"><em>Universal Machines</em></a>. (Bonus: <a href="https://dori-mic.org/"><em>Dori-Mic and the Universal Machine!</em></a> - this children&rsquo;s book has been called <a href="https://www.amazon.com/review/R1TSEFIBYW9Y6I/ref=cm_cr_dp_title?ie=UTF8&amp;ASIN=1495944980&amp;channel=detail-glance&amp;nodeID=283155&amp;store=books">&ldquo;The BEST babies&rsquo; book about computational universality I&rsquo;ve read.&quot;</a>.)</li>
<li>To understand why there are some uncomputable functions (not necessary for this course, but you should want to know!), see <a href="https://www.youtube.com/watch?v=Cuf4zkYwGlQ&amp;feature=emb_imp_woyt"><em>Uncomputable Numbers</em></a>.
</div>
</li>
</ul>
<h1 id="nbsp"> </h1>
<p><strong>Next: <a href="/complexity">Computational Complexity</a></strong></p>

      </div>

      <meta itemprop="wordCount" content="1798">
      <meta itemprop="datePublished" content="2021-12-26">
      <meta itemprop="url" content="https://computingbiology.github.io/models/">
    </article>
</div>


    </main>
    
    
<footer class="whatisthis">
  <hr />
  <div class="row">
    <div class="column small-12 medium-6">
      <a href="//computingbiology.github.io"><b>cs 4501: Computational Biology / Biological Computing</b></a><br>
      <a href="//www.cs.virginia.edu">University of Virginia</a>
    </div>
    <div class="column small-14 medium-5">
      <font size="-1">
      Subscribe to
	the <a href="/index.xml"><i class="fa fa-rss-square"></i>&nbsp;RSS feed</a>.
      <a id="searchsite">
	<form method="get" action="https://duckduckgo.com/">
	  <label for="search-field" class="show-for-sr">Search with DuckDuckGo</label>
	  <input type="search" name="q" maxlength="255" placeholder="Search with DuckDuckGo" id="search-field">
	  <input type="hidden" name="sites" value="https://computingbiology.github.io/"/>
	  <input type="hidden" name="k7" value="#faf8f8"/>
	  <input type="hidden" name="kj" value="#b33"/>
	  <input type="hidden" name="ky" value="#fafafa"/>
	  <input type="hidden" name="kx" value="b"/>
	  <input type="hidden" name="ko" value="-1"/>
	  <input type="hidden" name="k1" value="-1"/>
	  <input type="submit" value="DuckDuckGo Search" style="visibility: hidden;" />
	</form>
      </a>
</font>
    </div>
  </div>
  </hr>

</footer>



    
    <div class="endofpage">
    </div>

    <script src="/js/jquery.js"></script>
    <script src="/js/what-input.js"></script>
    <script src="/js/foundation.min.js"></script>
    <script src="/js/finite.js"></script>

    
    <script src="/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    
    
    
  </body>
</html>
